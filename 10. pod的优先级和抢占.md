---
title: pod的优先级和抢占
date: 2019-12-10 15:26
tags: 
  - 
categories: 
  - 
---

[TOC]



# 概述

​		Pod是有优先级的，pod的优先级是相对于其他pod，如果一个pod不能调度成功，scheduler为了调度成功，会尝试驱逐低优先级的pod。
​		在v1.9以后的版本，优先级会影响pod的调度顺序，以及在node节点资源不足的时候驱逐的顺序。

​	在v1.11版本这个功能被提升为beta功能，并默认启用，在v1.14版本以后被提升为稳定功能。

​	从v1.12版本新增一个ResourceQuota 的beta功能，集群中的所有用户并不是全部可信的，一个用户如果设置了pod很高的优先级，会引起其他用户的pod被驱逐或者无法调度。为了解决这个问题 [ResourceQuota](https://kubernetes.io/docs/concepts/policy/resource-quotas/) 是pod的一个增强功能，管理员可以给用户设置 ResourceQuota 明确其优先级，防止这些用户创建一个很高的优先级。

# 使用priority 和preemption

1. 添加一个PriorityClass 对象；
2. 在创建pod的时候指定 `priorityClassName` 

如果想要关闭这个功能，那么需要先移除 PodPriority 或者设置为`false`，然后重启API server和scheduler服务。在关闭了这个功能以后，那么已经设置的在运行的pod的优先级会被忽略，然后再新的pod中将不能再设置`priorityClassName` 。

## 关闭 preemption

> v1.12版本以后，不建议关闭preemption；
>
> v1.15版本以后，`NonPreemptingPriority` 默认enabled，PriorityClasse 有一个可选配置`preemptionPolicy: Never` .可以关闭这个pod的驱逐其他pod；

从v1.11版本以后，由kube-scheduler 的`disablePreemption`来控制preemption，默认是`false`。如果需要关闭preemption，可以设置其为`true`。

# PriorityClass 

​		PriorityClass是一个非namepace的对象，优先级是一个小于或等于十亿的整数，值越大优先级越高。关键系统可以设置一个很大的优先级，可以防止被驱逐或抢占。

​		PriorityClass 有两个可配置字段，`globalDefault`和`description`。`globalDefault` 表示当一个pod没有设置`priorityClassName`的时候会默认使用这个PriorityClass。一个集群中只能有一个priorityClass可以设置为`true`，如果没有priorityClass的`globalDefault`设置为true，则pod没有`priorityClassName`。`description` 是一个对PriorityClass的描述信息。

## 集群的PodPriority 的注意问题

		- 如果更新了集群，然后开启了这个功能，则已经运行的pod的优先级为0；
		- 给某一个PriorityClass 配置`globalDefault`为`true`以后，已经运行的pod的优先级不会改变；这个只能应用于后面创建的pod；
		- 如果删除了某一个PriorityClass，已经在用这个PriorityClass的pod不会修改，但是不能在用这个PriorityClass创建新的pod；

## PriotityClass 例子

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "This priority class should be used for XYZ service pods only."
```

## Non-preempting的PriorityClass(alpha)

​		v1.15版本添加了一个`PreemptionPolicy` 选项，默认是禁用的，如果需要这个功能要启用`NonPreemptingPriority` 组件。

​		`PreemptionPolicy` 的默认值是`PreemptLowerPriority` ，为了能成功调度这个pod，会驱逐其他优先级低的pod；

​		`PreemptionPolicy`  的值如果设置为`Never`，则不会驱逐其他优先级低的pod，然后这个pod的调度会添加到调度队列中，只不过会添加队列中低优先级的pod的前面；Non-preempting pod也会被其他其他高优先级的pod驱逐；

使用场景：一个用户提交了一个高优先级的pod，但是也不希望驱逐其他正在运行的pod，那么可以设置一个高优先级的pod 加上`PreemptionPolicy: Never`  。

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority-nonpreempting
value: 1000000		#优先级
preemptionPolicy: Never		#不驱逐其他pod
globalDefault: false		#非全局默认
description: "This priority class will not cause other pods to be preempted."	#描述
```

# Pod priority

​		当创建好PriorityClass以后，可以给pod用`priorityClassName`关联PriorityClass，然后再创建的时候pod会使用关键的PriorityClass的优先级，如果没有找到关联的PriorityClass，那么pod将无法创建。

## Pod priority 对调度顺序的影响

在v1.9及以后的版本中，当Pod priority 启用以后，scheduler会按照pod的优先级来安排在队列中的顺序。一旦满足调度条件以后，高优先级的pod会优先调度，如果这个高优先级的pod还是调度失败了，那么scheduler会按照队列顺序调度后面低优先级的pod。

# Preemption

​		当pod创建以后，会被加入到调度队列中等待调度运行。scheduler会尝试把pod调度到node节点上，如果没有节点有适合的资源，pod的状态会变成pending，然后会触发preemption logic进程，preemption logic会在一个合适的node节点上终止一个或多个相对低优先级的pod，当这些pod终止以后，被调度的pod会调度到node节点上运行。

## 用户可以配置的preemption信息

​		当一个pod （例子P）抢占其他pod的资源的时候，会先检查`nominatedNodeName` 字段设置的node（例子A）名称，这个字段用来帮助scheduler 选择哪个node上的pod被终止驱逐；

​		注意的是，这个pod（P）并不一定会被调度到“nominated node"（A）上，被驱逐的pod会被执行graceful termination 。如果在执行 preempt期间，另一个node（例子B）有足够的资源可以调度，那么pod将会调度到这个另一个node（B）上，结果就会造成实际运行的node和"nominated node"不一致的情况。

​		如果在pod（P）preempt 其他pod期间，有一个更高优先级的pod（P1）进入调度队列，那么node（A）上的资源将会被pod（P1）占用，这种情况下，pod（P）也不会被调度到"nominated node"上，那么scheduler将会把pod（P）调度到其他节点上。

## preemption的局限性

### Graceful termination被驱逐的pod

​		在开始抢占其他pod的资源的时候，这些pod将进入graceful termination阶段，以保证pod里面的进程可以正常结束退出。在这个时间间隙里面，scheduler会继续调度队列里面的其他pod。

​		那么一个pod调度的时间 = 其他pod 结束的时间 + pod调度的时间。 为了减少这个时间，graceful termination阶段占用的时间我们可以手动设置为0或者一个很小的时间。

### 支持PDB，但是不保证总是有效

PDB用于限制一个应用可以同时”自愿“终止的副本的数量，v1.9版本支持在preempting pod上的PDB，仅仅能保证尽量满足PDB的规则。scheduler会检查被驱逐终止的pod上的PDB的规则，如果没有违反PDB规则，那么preempt会继续进行。

### inter-Pod 亲和性在低优先级pod上的作用

​		如果pod上的inter-pod 是关联到低优先级的pod，那么没有低优先级的pod的node节点将无法满足这个pod上的inter-pod条件，相应的，pod也无法调度到这个node上，scheduler会检测其他的node节点，甚至可能出现无法调度这个pod的情况。

为了避免这种情况发生，我们建议pod上的inter-pod关联的其他pod的优先级等于或高于本pod。

### 跨node节点的preemption

如果pod P 上有设置anti-anffinity策略，那么就会出现scheduler需要跨node节点preeemption的情况：

- 按照正常调度规则pod P 会被调度到node N 上；
- pod Q 也运行在了node N这个zone上；
- pod P 和pod Q之间有一条anti-anffinity策略 (`topologyKey: failure-domain.beta.kubernetes.io/zone`)；
- 那么会出现pod P和pod Q不能在同一个zone的情况，所以pod P不能调度到这个node N上；
- 如果Pod Q 从zone 的节点上终止了，那么pod P可以调度到node N上，但是preemption目前不支持跨node的preemtion；

